ðŸ›  Individual Contribution: Implementation & Logic Design
As the lead for the Implementation Logic, I designed and documented the core execution lifecycle of the keylogger. My primary focus was on ensuring a low system footprint while maintaining high data capture accuracy through direct OS interaction.

ðŸ“‹ Technical Workflow Analysis
1. Stealth Initialization
The first barrier to a successful keylogger is the user interface. I implemented a stealth-first boot sequence to ensure the process remains unobtrusive.

Mechanism: Immediate execution of ShowWindow(GetConsoleWindow(), SW_HIDE).

Impact: Detaches the process from the visible terminal. While the process remains traceable in the Windows Task Manager, it is removed from the Taskbar and Desktop environment, effectively hiding it from non-technical users.

2. Global Input Polling
To capture keystrokes regardless of which window is in focus, I moved away from standard C++ streams (cin) in favor of a global polling mechanism.

Logic: Created an infinite while(true) loop within the StartLogging function.

The Scan: The loop iterates through Virtual-Key codes (1 to 254). This comprehensive range allows the program to detect alphanumeric keys, function keys (F1â€“F12), and system modifiers (Shift, Ctrl, Alt).

3. Asynchronous State Detection
I utilized the Windows API GetAsyncKeyState() to bridge the gap between hardware input and software logging.

State Check: Unlike synchronous functions, this queries the hardware state directly. By checking if the most significant bit is set, the program identifies a "pressed" state.

Precision (Debouncing): I implemented logic to prevent "key-bouncing" (multiple logs for a single press), ensuring the log.txt remains clean and human-readable.

4. Atomic File I/O Management
To prevent data corruption during unexpected system shutdowns, I implemented an Atomic Append strategy.

Append Mode: Utilized std::ofstream with the ios::app flag to ensure existing logs are never overwritten.

Resource Management: Designed an Open-Write-Close cycle for every captured stroke. This prevents the OS from "locking" the file, ensuring that the logs are saved to the disk in real-time and remain accessible for exfiltration.

5. Process Persistence
I analyzed and documented the malware's persistence to highlight its security impact.

Zombie Process: The loop lacks a standard "exit" condition, simulating real-world malware behavior.

Termination Analysis: I identified that only high-level system interrupts (e.g., SIGTERM via Task Manager or a full system shutdown) can halt the execution, demonstrating the difficulty of manual removal.



